#!/usr/bin/env python

import StringIO
import sys
import traceback

import clang.cindex
from clang.cindex import CursorKind, Diagnostic


def main(argv):
    global args
    args = parse_args(argv)

    index = clang.cindex.Index.create()

    try:
        tu = index.parse(None, args.compiler_command_line) # a Translation Unit
    except Exception as e:
        debug(traceback.format_exc())
        error("Clang failed to parse " +
              " ".join(args.compiler_command_line))

    errors = [d for d in tu.diagnostics
              if d.severity in (Diagnostic.Error, Diagnostic.Fatal)]
    if len(errors) > 0:
        debug("\n".join([d.spelling for d in errors]))
        error("File '%s' failed clang's parsing and type-checking" %
              tu.spelling)

    formatter = Etags(tu.spelling) if args.etags else Ctags(tu.spelling)
    for c in tu.cursor.get_children():
        do_tags(c, formatter, tu.spelling)

    if args.output == "-":
        out = sys.stdout
    else:
        out = open(args.output, ("a" if args.append else "w") + "b")
    out.write(formatter.getvalue())


def do_tags(cursor, formatter, filename):
    if not cursor.location.file or cursor.location.file.name != filename:
        return

    if is_definition(cursor):
        parents = semantic_parents(cursor)
        formatter.tag(cursor, "::" + "::".join(parents + [cursor.displayname]))
        for i in range(len(parents) + 1):
            formatter.tag(cursor, "::".join(parents[i:] + [cursor.displayname]))

    if is_named_scope(cursor):
        for c in cursor.get_children():
            do_tags(c, formatter, filename)


def is_definition(cursor):
    return cursor.is_definition() and not cursor.kind in [
        CursorKind.CXX_ACCESS_SPEC_DECL,
        CursorKind.TEMPLATE_TYPE_PARAMETER,
        ]


def semantic_parents(cursor):
    import collections

    p = collections.deque()
    c = cursor.semantic_parent
    while c and is_named_scope(c):
        p.appendleft(c.displayname)
        c = c.semantic_parent
    return list(p)


def is_named_scope(cursor):
    return cursor.kind in [
        CursorKind.NAMESPACE,
        CursorKind.STRUCT_DECL,
        CursorKind.UNION_DECL,
        CursorKind.ENUM_DECL,
        CursorKind.CLASS_DECL,
        CursorKind.CLASS_TEMPLATE,
        ]


class Etags:
    """Write tags in the format understood by Emacs.

    See http://bzr.savannah.gnu.org/lh/emacs/trunk/annotate/head:/etc/ETAGS.EBNF
    """

    def __init__(self, filename):
        with open(filename) as f:
            self.lines = f.readlines()
        self.out = StringIO.StringIO()
        self.out.write("\x0c\x0a" + filename + ",\x0a")

    def getvalue(self):
        return self.out.getvalue()

    def tag(self, cursor, tagname):
        """The complete tags file entry for symbol 'tag'."""
        self.out.write("%s\x7f%s\x01%d,%d\x0a" % (
                self.lines[cursor.location.line - 1].rstrip(),
                tagname,
                cursor.location.line, cursor.location.offset))


class Ctags:
    """Write tags in the format understood by Vi.

    Not yet implemented. The man page for Exuberant Ctags
    (http://ctags.sourceforge.net) documents the tags file format.
    """

    def  __init__(self, filename):
        error("Ctags (vi) format not implemented. "
              "Use '-e' for etags (Emacs) format.")


def parse_args(argv):
    import argparse
    import re

    parser = argparse.ArgumentParser(
        description="Generate tag file for C++ source code.",
        usage="clang-ctags [-e] [-a] [-f file] [-v] -- compiler command line...")
    parser.add_argument("-e", action="store_true",
                        help='output tags in Emacs format (default: vi format)'
                             ' (implied if the program name contains "etags")')
    parser.add_argument("-a", "--append", action="store_true",
                        help="append tag entries to existing tag file")
    parser.add_argument("-f", "-o", "--output", metavar="FILE",
                        help='write the tags to %(metavar)s;'
                             ' "-" writes tags to stdout'
                             ' (default: "tags", or "TAGS" when -e supplied)')
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="enable debugging output")
    parser.add_argument("--version", action="version",
                        version="clang-ctags 1.0rc")
    parser.add_argument("compiler_command_line", nargs="+")

    a = parser.parse_args(argv[1:])
    a.etags = bool(a.e or re.search("etags", argv[0]))
    if not a.output:
        a.output = "TAGS" if a.etags else "tags"
    return a


def debug(s):
    if args.verbose:
        sys.stderr.write(s + "\n")


def error(s):
    from os.path import basename
    sys.stderr.write("%s: Error: %s\n" % (basename(sys.argv[0]), s))
    sys.exit(1)


if __name__ == "__main__":
    sys.exit(main(sys.argv))
